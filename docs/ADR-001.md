ADR-001: Database Selection — MongoDB over Firebase 

-----------------------------------------------------------------

Context 

-----------------------------------------------------------------

The travel suggestion application requires a database to store user preferences, saved destinations, and travel-related metadata. The backend must support complex and flexible querying to generate destination suggestions based on multiple criteria such as budget, interests, dates, and possibly even historical user behavior. 

Key forces/constraints: 

	- The application may require intricate queries, including: 

	- Multi-field queries 

 	- Conditional logic 

	- Array and nested queries 

Backend is built using Node.js / Express, where tight integration with the database query layer is important. 

The data model may evolve as recommendation logic becomes more sophisticated. 

Queries must remain readable, maintainable, and efficient as complexity increases. 

Firebase was evaluated as an alternative due to its simplicity and ease of setup, but its querying model is more limited and optimized for simple queries. 

-----------------------------------------------------------------

Decision 

-----------------------------------------------------------------


We chose MongoDB as the primary database over Firebase. 

MongoDB was selected because it offers greater complexity and expressive power in queries, allowing us to support complex filtering, aggregation, and evolving data relationships. Its model aligns well with the flexible and nested structure of travel preference data. 

Firebase was not chosen because, while simpler to use, it provides weaker querying capabilities, particularly for multi-criteria searches and advanced filtering logic that the application may require as it grows. 

 
-----------------------------------------------------------------

Status

-----------------------------------------------------------------
 

- Accepted 

 




-----------------------------------------------------------------

Consequences 

-----------------------------------------------------------------


Positive Outcomes: 

Ability to perform complex, multi-criteria queries needed for travel recommendations 

Strong support for nested documents and arrays, which we believe will match the application’s data model 

Greater control over query optimization and indexing 

Easier evolution of data structures if business logic becomes more advanced 

Familiar tooling, patterns, and documentation within a Node.js backend 

Negative Outcomes:  

Increased setup and complexity compared to Firebase 

Requires more explicit schema and index management 

Slightly higher learning curve for developers unfamiliar with MongoDB’s query language 

Remaining Risks:  

Poorly designed queries or missing indexes could impact performance 

Schema flexibility may lead to inconsistency if not governed by conventions or validation 

Operational responsibility (scaling, backups) must be managed carefully if not using a fully managed service 
